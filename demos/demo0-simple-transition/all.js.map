{"version":3,"file":"all.js","sources":["../../node_modules/preact/src/vnode.js","../../node_modules/preact/src/h.js","../../node_modules/preact/src/util.js","../../node_modules/preact/src/render-queue.js","../../node_modules/preact/src/vdom/index.js","../../node_modules/preact/src/dom/index.js","../../node_modules/preact/src/vdom/diff.js","../../node_modules/preact/src/vdom/component-recycler.js","../../node_modules/preact/src/vdom/component.js","../../node_modules/preact/src/component.js","../../src/mapToZero.js","../../src/stripStyle.js","../../src/stepper.js","../../src/shouldStopAnimation.js","../../node_modules/fbjs/lib/emptyFunction.js","../../src/StaggeredMotion.js","../../src/mergeDiff.js","../../src/TransitionMotion.js","../../src/spring.js","../../node_modules/preact/src/options.js","../../node_modules/preact/src/constants.js","../../node_modules/raf/index.js","../../node_modules/performance-now/lib/performance-now.js","../../src/Motion.js","../../src/presets.js","Demo.jsx","../../node_modules/preact/src/render.js","index.jsx"],"sourcesContent":["/** Virtual DOM Node */\nexport function VNode() {}\n","import { VNode } from './vnode';\nimport options from './options';\n\n\nconst stack = [];\n\nconst EMPTY_CHILDREN = [];\n\n/** JSX/hyperscript reviver\n*\tBenchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0\n *\t@see http://jasonformat.com/wtf-is-jsx\n *\t@public\n */\nexport function h(nodeName, attributes) {\n\tlet children=EMPTY_CHILDREN, lastSimple, child, simple, i;\n\tfor (i=arguments.length; i-- > 2; ) {\n\t\tstack.push(arguments[i]);\n\t}\n\tif (attributes && attributes.children!=null) {\n\t\tif (!stack.length) stack.push(attributes.children);\n\t\tdelete attributes.children;\n\t}\n\twhile (stack.length) {\n\t\tif ((child = stack.pop()) && child.pop!==undefined) {\n\t\t\tfor (i=child.length; i--; ) stack.push(child[i]);\n\t\t}\n\t\telse {\n\t\t\tif (child===true || child===false) child = null;\n\n\t\t\tif ((simple = typeof nodeName!=='function')) {\n\t\t\t\tif (child==null) child = '';\n\t\t\t\telse if (typeof child==='number') child = String(child);\n\t\t\t\telse if (typeof child!=='string') simple = false;\n\t\t\t}\n\n\t\t\tif (simple && lastSimple) {\n\t\t\t\tchildren[children.length-1] += child;\n\t\t\t}\n\t\t\telse if (children===EMPTY_CHILDREN) {\n\t\t\t\tchildren = [child];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\n\t\t\tlastSimple = simple;\n\t\t}\n\t}\n\n\tlet p = new VNode();\n\tp.nodeName = nodeName;\n\tp.children = children;\n\tp.attributes = attributes==null ? undefined : attributes;\n\tp.key = attributes==null ? undefined : attributes.key;\n\n\t// if a \"vnode hook\" is defined, pass every created VNode to it\n\tif (options.vnode!==undefined) options.vnode(p);\n\n\treturn p;\n}\n","/** Copy own-properties from `props` onto `obj`.\n *\t@returns obj\n *\t@private\n */\nexport function extend(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn obj;\n}\n\n\n","import options from './options';\nimport { renderComponent } from './vdom/component';\n\n/** Managed queue of dirty components to be re-rendered */\n\nlet items = [];\n\nexport function enqueueRender(component) {\n\tif (!component._dirty && (component._dirty = true) && items.push(component)==1) {\n\t\t(options.debounceRendering || setTimeout)(rerender);\n\t}\n}\n\n\nexport function rerender() {\n\tlet p, list = items;\n\titems = [];\n\twhile ( (p = list.pop()) ) {\n\t\tif (p._dirty) renderComponent(p);\n\t}\n}\n","import { extend } from '../util';\n\n\n/** Check if two nodes are equivalent.\n *\t@param {Element} node\n *\t@param {VNode} vnode\n *\t@private\n */\nexport function isSameNodeType(node, vnode, hydrating) {\n\tif (typeof vnode==='string' || typeof vnode==='number') {\n\t\treturn node.splitText!==undefined;\n\t}\n\tif (typeof vnode.nodeName==='string') {\n\t\treturn !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n\t}\n\treturn hydrating || node._componentConstructor===vnode.nodeName;\n}\n\n\n/** Check if an Element has a given normalized name.\n*\t@param {Element} node\n*\t@param {String} nodeName\n */\nexport function isNamedNode(node, nodeName) {\n\treturn node.normalizedNodeName===nodeName || node.nodeName.toLowerCase()===nodeName.toLowerCase();\n}\n\n\n/**\n * Reconstruct Component-style `props` from a VNode.\n * Ensures default/fallback values from `defaultProps`:\n * Own-properties of `defaultProps` not present in `vnode.attributes` are added.\n * @param {VNode} vnode\n * @returns {Object} props\n */\nexport function getNodeProps(vnode) {\n\tlet props = extend({}, vnode.attributes);\n\tprops.children = vnode.children;\n\n\tlet defaultProps = vnode.nodeName.defaultProps;\n\tif (defaultProps!==undefined) {\n\t\tfor (let i in defaultProps) {\n\t\t\tif (props[i]===undefined) {\n\t\t\t\tprops[i] = defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn props;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n\n/** Create an element with the given nodeName.\n *\t@param {String} nodeName\n *\t@param {Boolean} [isSvg=false]\tIf `true`, creates an element within the SVG namespace.\n *\t@returns {Element} node\n */\nexport function createNode(nodeName, isSvg) {\n\tlet node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);\n\tnode.normalizedNodeName = nodeName;\n\treturn node;\n}\n\n\n/** Remove a child node from its parent if attached.\n *\t@param {Element} node\t\tThe node to remove\n */\nexport function removeNode(node) {\n\tif (node.parentNode) node.parentNode.removeChild(node);\n}\n\n\n/** Set a named attribute on the given Node, with special behavior for some names and event handlers.\n *\tIf `value` is `null`, the attribute/handler will be removed.\n *\t@param {Element} node\tAn element to mutate\n *\t@param {string} name\tThe name/key to set, such as an event or attribute name\n *\t@param {any} old\tThe last value that was set for this name/node pair\n *\t@param {any} value\tAn attribute value, such as a function to be used as an event handler\n *\t@param {Boolean} isSvg\tAre we currently diffing inside an svg?\n *\t@private\n */\nexport function setAccessor(node, name, old, value, isSvg) {\n\tif (name==='className') name = 'class';\n\n\n\tif (name==='key') {\n\t\t// ignore\n\t}\n\telse if (name==='ref') {\n\t\tif (old) old(null);\n\t\tif (value) value(node);\n\t}\n\telse if (name==='class' && !isSvg) {\n\t\tnode.className = value || '';\n\t}\n\telse if (name==='style') {\n\t\tif (!value || typeof value==='string' || typeof old==='string') {\n\t\t\tnode.style.cssText = value || '';\n\t\t}\n\t\tif (value && typeof value==='object') {\n\t\t\tif (typeof old!=='string') {\n\t\t\t\tfor (let i in old) if (!(i in value)) node.style[i] = '';\n\t\t\t}\n\t\t\tfor (let i in value) {\n\t\t\t\tnode.style[i] = typeof value[i]==='number' && IS_NON_DIMENSIONAL.test(i)===false ? (value[i]+'px') : value[i];\n\t\t\t}\n\t\t}\n\t}\n\telse if (name==='dangerouslySetInnerHTML') {\n\t\tif (value) node.innerHTML = value.__html || '';\n\t}\n\telse if (name[0]=='o' && name[1]=='n') {\n\t\tlet useCapture = name !== (name=name.replace(/Capture$/, ''));\n\t\tname = name.toLowerCase().substring(2);\n\t\tif (value) {\n\t\t\tif (!old) node.addEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\telse {\n\t\t\tnode.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(node._listeners || (node._listeners = {}))[name] = value;\n\t}\n\telse if (name!=='list' && name!=='type' && !isSvg && name in node) {\n\t\tsetProperty(node, name, value==null ? '' : value);\n\t\tif (value==null || value===false) node.removeAttribute(name);\n\t}\n\telse {\n\t\tlet ns = isSvg && (name !== (name = name.replace(/^xlink\\:?/, '')));\n\t\tif (value==null || value===false) {\n\t\t\tif (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());\n\t\t\telse node.removeAttribute(name);\n\t\t}\n\t\telse if (typeof value!=='function') {\n\t\t\tif (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);\n\t\t\telse node.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n\n/** Attempt to set a DOM property to the given value.\n *\tIE & FF throw for certain property-value combinations.\n */\nfunction setProperty(node, name, value) {\n\ttry {\n\t\tnode[name] = value;\n\t} catch (e) { }\n}\n\n\n/** Proxy an event to hooked event handlers\n *\t@private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type](options.event && options.event(e) || e);\n}\n","import { ATTR_KEY } from '../constants';\nimport { isSameNodeType, isNamedNode } from './index';\nimport { buildComponentFromVNode } from './component';\nimport { createNode, setAccessor } from '../dom/index';\nimport { unmountComponent } from './component';\nimport options from '../options';\nimport { removeNode } from '../dom';\n\n/** Queue of components that have been mounted and are awaiting componentDidMount */\nexport const mounts = [];\n\n/** Diff recursion count, used to track the end of the diff cycle. */\nexport let diffLevel = 0;\n\n/** Global flag indicating if the diff is currently within an SVG */\nlet isSvgMode = false;\n\n/** Global flag indicating if the diff is performing hydration */\nlet hydrating = false;\n\n/** Invoke queued componentDidMount lifecycle methods */\nexport function flushMounts() {\n\tlet c;\n\twhile ((c=mounts.pop())) {\n\t\tif (options.afterMount) options.afterMount(c);\n\t\tif (c.componentDidMount) c.componentDidMount();\n\t}\n}\n\n\n/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.\n *\t@param {Element} [dom=null]\t\tA DOM node to mutate into the shape of the `vnode`\n *\t@param {VNode} vnode\t\t\tA VNode (with descendants forming a tree) representing the desired DOM structure\n *\t@returns {Element} dom\t\t\tThe created/mutated element\n *\t@private\n */\nexport function diff(dom, vnode, context, mountAll, parent, componentRoot) {\n\t// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)\n\tif (!diffLevel++) {\n\t\t// when first starting the diff, check if we're diffing an SVG or within an SVG\n\t\tisSvgMode = parent!=null && parent.ownerSVGElement!==undefined;\n\n\t\t// hydration is inidicated by the existing element to be diffed not having a prop cache\n\t\thydrating = dom!=null && !(ATTR_KEY in dom);\n\t}\n\n\tlet ret = idiff(dom, vnode, context, mountAll, componentRoot);\n\n\t// append the element if its a new parent\n\tif (parent && ret.parentNode!==parent) parent.appendChild(ret);\n\n\t// diffLevel being reduced to 0 means we're exiting the diff\n\tif (!--diffLevel) {\n\t\thydrating = false;\n\t\t// invoke queued componentDidMount lifecycle methods\n\t\tif (!componentRoot) flushMounts();\n\t}\n\n\treturn ret;\n}\n\n\n/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */\nfunction idiff(dom, vnode, context, mountAll, componentRoot) {\n\tlet out = dom,\n\t\tprevSvgMode = isSvgMode;\n\n\t// empty values (null & undefined) render as empty Text nodes\n\tif (vnode==null) vnode = '';\n\n\n\t// Fast case: Strings create/update Text nodes.\n\tif (typeof vnode==='string') {\n\n\t\t// update if it's already a Text node:\n\t\tif (dom && dom.splitText!==undefined && dom.parentNode && (!dom._component || componentRoot)) {\n\t\t\tif (dom.nodeValue!=vnode) {\n\t\t\t\tdom.nodeValue = vnode;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// it wasn't a Text node: replace it with one and recycle the old Element\n\t\t\tout = document.createTextNode(vnode);\n\t\t\tif (dom) {\n\t\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\t\t\t\trecollectNodeTree(dom, true);\n\t\t\t}\n\t\t}\n\n\t\tout[ATTR_KEY] = true;\n\n\t\treturn out;\n\t}\n\n\n\t// If the VNode represents a Component, perform a component diff:\n\tif (typeof vnode.nodeName==='function') {\n\t\treturn buildComponentFromVNode(dom, vnode, context, mountAll);\n\t}\n\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvgMode = vnode.nodeName==='svg' ? true : vnode.nodeName==='foreignObject' ? false : isSvgMode;\n\n\n\t// If there's no existing element or it's the wrong type, create a new one:\n\tif (!dom || !isNamedNode(dom, String(vnode.nodeName))) {\n\t\tout = createNode(String(vnode.nodeName), isSvgMode);\n\n\t\tif (dom) {\n\t\t\t// move children into the replacement node\n\t\t\twhile (dom.firstChild) out.appendChild(dom.firstChild);\n\n\t\t\t// if the previous Element was mounted into the DOM, replace it inline\n\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\n\t\t\t// recycle the old element (skips non-Element node types)\n\t\t\trecollectNodeTree(dom, true);\n\t\t}\n\t}\n\n\n\tlet fc = out.firstChild,\n\t\tprops = out[ATTR_KEY] || (out[ATTR_KEY] = {}),\n\t\tvchildren = vnode.children;\n\n\t// Optimization: fast-path for elements containing a single TextNode:\n\tif (!hydrating && vchildren && vchildren.length===1 && typeof vchildren[0]==='string' && fc!=null && fc.splitText!==undefined && fc.nextSibling==null) {\n\t\tif (fc.nodeValue!=vchildren[0]) {\n\t\t\tfc.nodeValue = vchildren[0];\n\t\t}\n\t}\n\t// otherwise, if there are existing or new children, diff them:\n\telse if (vchildren && vchildren.length || fc!=null) {\n\t\tinnerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML!=null);\n\t}\n\n\n\t// Apply attributes/props from VNode to the DOM Element:\n\tdiffAttributes(out, vnode.attributes, props);\n\n\n\t// restore previous SVG mode: (in case we're exiting an SVG namespace)\n\tisSvgMode = prevSvgMode;\n\n\treturn out;\n}\n\n\n/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.\n *\t@param {Element} dom\t\t\tElement whose children should be compared & mutated\n *\t@param {Array} vchildren\t\tArray of VNodes to compare to `dom.childNodes`\n *\t@param {Object} context\t\t\tImplicitly descendant context object (from most recent `getChildContext()`)\n *\t@param {Boolean} mountAll\n *\t@param {Boolean} isHydrating\tIf `true`, consumes externally created elements similar to hydration\n */\nfunction innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {\n\tlet originalChildren = dom.childNodes,\n\t\tchildren = [],\n\t\tkeyed = {},\n\t\tkeyedLen = 0,\n\t\tmin = 0,\n\t\tlen = originalChildren.length,\n\t\tchildrenLen = 0,\n\t\tvlen = vchildren ? vchildren.length : 0,\n\t\tj, c, vchild, child;\n\n\t// Build up a map of keyed children and an Array of unkeyed children:\n\tif (len!==0) {\n\t\tfor (let i=0; i<len; i++) {\n\t\t\tlet child = originalChildren[i],\n\t\t\t\tprops = child[ATTR_KEY],\n\t\t\t\tkey = vlen && props ? child._component ? child._component.__key : props.key : null;\n\t\t\tif (key!=null) {\n\t\t\t\tkeyedLen++;\n\t\t\t\tkeyed[key] = child;\n\t\t\t}\n\t\t\telse if (props || (child.splitText!==undefined ? (isHydrating ? child.nodeValue.trim() : true) : isHydrating)) {\n\t\t\t\tchildren[childrenLen++] = child;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vlen!==0) {\n\t\tfor (let i=0; i<vlen; i++) {\n\t\t\tvchild = vchildren[i];\n\t\t\tchild = null;\n\n\t\t\t// attempt to find a node based on key matching\n\t\t\tlet key = vchild.key;\n\t\t\tif (key!=null) {\n\t\t\t\tif (keyedLen && keyed[key]!==undefined) {\n\t\t\t\t\tchild = keyed[key];\n\t\t\t\t\tkeyed[key] = undefined;\n\t\t\t\t\tkeyedLen--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// attempt to pluck a node of the same type from the existing children\n\t\t\telse if (!child && min<childrenLen) {\n\t\t\t\tfor (j=min; j<childrenLen; j++) {\n\t\t\t\t\tif (children[j]!==undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {\n\t\t\t\t\t\tchild = c;\n\t\t\t\t\t\tchildren[j] = undefined;\n\t\t\t\t\t\tif (j===childrenLen-1) childrenLen--;\n\t\t\t\t\t\tif (j===min) min++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// morph the matched/found/created DOM child to match vchild (deep)\n\t\t\tchild = idiff(child, vchild, context, mountAll);\n\n\t\t\tif (child && child!==dom) {\n\t\t\t\tif (i>=len) {\n\t\t\t\t\tdom.appendChild(child);\n\t\t\t\t}\n\t\t\t\telse if (child!==originalChildren[i]) {\n\t\t\t\t\tif (child===originalChildren[i+1]) {\n\t\t\t\t\t\tremoveNode(originalChildren[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdom.insertBefore(child, originalChildren[i] || null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// remove unused keyed children:\n\tif (keyedLen) {\n\t\tfor (let i in keyed) if (keyed[i]!==undefined) recollectNodeTree(keyed[i], false);\n\t}\n\n\t// remove orphaned unkeyed children:\n\twhile (min<=childrenLen) {\n\t\tif ((child = children[childrenLen--])!==undefined) recollectNodeTree(child, false);\n\t}\n}\n\n\n\n/** Recursively recycle (or just unmount) a node an its descendants.\n *\t@param {Node} node\t\t\t\t\t\tDOM node to start unmount/removal from\n *\t@param {Boolean} [unmountOnly=false]\tIf `true`, only triggers unmount lifecycle, skips removal\n */\nexport function recollectNodeTree(node, unmountOnly) {\n\tlet component = node._component;\n\tif (component) {\n\t\t// if node is owned by a Component, unmount that component (ends up recursing back here)\n\t\tunmountComponent(component);\n\t}\n\telse {\n\t\t// If the node's VNode had a ref function, invoke it with null here.\n\t\t// (this is part of the React spec, and smart for unsetting references)\n\t\tif (node[ATTR_KEY]!=null && node[ATTR_KEY].ref) node[ATTR_KEY].ref(null);\n\n\t\tif (unmountOnly===false || node[ATTR_KEY]==null) {\n\t\t\tremoveNode(node);\n\t\t}\n\n\t\tremoveChildren(node);\n\t}\n}\n\n\n/** Recollect/unmount all children.\n *\t- we use .lastChild here because it causes less reflow than .firstChild\n *\t- it's also cheaper than accessing the .childNodes Live NodeList\n */\nexport function removeChildren(node) {\n\tnode = node.lastChild;\n\twhile (node) {\n\t\tlet next = node.previousSibling;\n\t\trecollectNodeTree(node, true);\n\t\tnode = next;\n\t}\n}\n\n\n/** Apply differences in attributes from a VNode to the given DOM Element.\n *\t@param {Element} dom\t\tElement with attributes to diff `attrs` against\n *\t@param {Object} attrs\t\tThe desired end-state key-value attribute pairs\n *\t@param {Object} old\t\t\tCurrent/previous attributes (from previous VNode or element's prop cache)\n */\nfunction diffAttributes(dom, attrs, old) {\n\tlet name;\n\n\t// remove attributes no longer present on the vnode by setting them to undefined\n\tfor (name in old) {\n\t\tif (!(attrs && attrs[name]!=null) && old[name]!=null) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);\n\t\t}\n\t}\n\n\t// add new & update changed attributes\n\tfor (name in attrs) {\n\t\tif (name!=='children' && name!=='innerHTML' && (!(name in old) || attrs[name]!==(name==='value' || name==='checked' ? dom[name] : old[name]))) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n\t\t}\n\t}\n}\n","import { Component } from '../component';\n\n/** Retains a pool of Components for re-use, keyed on component name.\n *\tNote: since component names are not unique or even necessarily available, these are primarily a form of sharding.\n *\t@private\n */\nconst components = {};\n\n\n/** Reclaim a component for later re-use by the recycler. */\nexport function collectComponent(component) {\n\tlet name = component.constructor.name;\n\t(components[name] || (components[name] = [])).push(component);\n}\n\n\n/** Create a component. Normalizes differences between PFC's and classful Components. */\nexport function createComponent(Ctor, props, context) {\n\tlet list = components[Ctor.name],\n\t\tinst;\n\n\tif (Ctor.prototype && Ctor.prototype.render) {\n\t\tinst = new Ctor(props, context);\n\t\tComponent.call(inst, props, context);\n\t}\n\telse {\n\t\tinst = new Component(props, context);\n\t\tinst.constructor = Ctor;\n\t\tinst.render = doRender;\n\t}\n\n\n\tif (list) {\n\t\tfor (let i=list.length; i--; ) {\n\t\t\tif (list[i].constructor===Ctor) {\n\t\t\t\tinst.nextBase = list[i].nextBase;\n\t\t\t\tlist.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn inst;\n}\n\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { SYNC_RENDER, NO_RENDER, FORCE_RENDER, ASYNC_RENDER, ATTR_KEY } from '../constants';\nimport options from '../options';\nimport { extend } from '../util';\nimport { enqueueRender } from '../render-queue';\nimport { getNodeProps } from './index';\nimport { diff, mounts, diffLevel, flushMounts, recollectNodeTree, removeChildren } from './diff';\nimport { createComponent, collectComponent } from './component-recycler';\nimport { removeNode } from '../dom';\n\n/** Set a component's `props` (generally derived from JSX attributes).\n *\t@param {Object} props\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.renderSync=false]\tIf `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.\n *\t@param {boolean} [opts.render=true]\t\t\tIf `false`, no render will be triggered.\n */\nexport function setComponentProps(component, props, opts, context, mountAll) {\n\tif (component._disable) return;\n\tcomponent._disable = true;\n\n\tif ((component.__ref = props.ref)) delete props.ref;\n\tif ((component.__key = props.key)) delete props.key;\n\n\tif (!component.base || mountAll) {\n\t\tif (component.componentWillMount) component.componentWillMount();\n\t}\n\telse if (component.componentWillReceiveProps) {\n\t\tcomponent.componentWillReceiveProps(props, context);\n\t}\n\n\tif (context && context!==component.context) {\n\t\tif (!component.prevContext) component.prevContext = component.context;\n\t\tcomponent.context = context;\n\t}\n\n\tif (!component.prevProps) component.prevProps = component.props;\n\tcomponent.props = props;\n\n\tcomponent._disable = false;\n\n\tif (opts!==NO_RENDER) {\n\t\tif (opts===SYNC_RENDER || options.syncComponentUpdates!==false || !component.base) {\n\t\t\trenderComponent(component, SYNC_RENDER, mountAll);\n\t\t}\n\t\telse {\n\t\t\tenqueueRender(component);\n\t\t}\n\t}\n\n\tif (component.__ref) component.__ref(component);\n}\n\n\n\n/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.\n *\t@param {Component} component\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.build=false]\t\tIf `true`, component will build and store a DOM node if not already associated with one.\n *\t@private\n */\nexport function renderComponent(component, opts, mountAll, isChild) {\n\tif (component._disable) return;\n\n\tlet props = component.props,\n\t\tstate = component.state,\n\t\tcontext = component.context,\n\t\tpreviousProps = component.prevProps || props,\n\t\tpreviousState = component.prevState || state,\n\t\tpreviousContext = component.prevContext || context,\n\t\tisUpdate = component.base,\n\t\tnextBase = component.nextBase,\n\t\tinitialBase = isUpdate || nextBase,\n\t\tinitialChildComponent = component._component,\n\t\tskip = false,\n\t\trendered, inst, cbase;\n\n\t// if updating\n\tif (isUpdate) {\n\t\tcomponent.props = previousProps;\n\t\tcomponent.state = previousState;\n\t\tcomponent.context = previousContext;\n\t\tif (opts!==FORCE_RENDER\n\t\t\t&& component.shouldComponentUpdate\n\t\t\t&& component.shouldComponentUpdate(props, state, context) === false) {\n\t\t\tskip = true;\n\t\t}\n\t\telse if (component.componentWillUpdate) {\n\t\t\tcomponent.componentWillUpdate(props, state, context);\n\t\t}\n\t\tcomponent.props = props;\n\t\tcomponent.state = state;\n\t\tcomponent.context = context;\n\t}\n\n\tcomponent.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n\tcomponent._dirty = false;\n\n\tif (!skip) {\n\t\trendered = component.render(props, state, context);\n\n\t\t// context to pass to the child, can be updated via (grand-)parent component\n\t\tif (component.getChildContext) {\n\t\t\tcontext = extend(extend({}, context), component.getChildContext());\n\t\t}\n\n\t\tlet childComponent = rendered && rendered.nodeName,\n\t\t\ttoUnmount, base;\n\n\t\tif (typeof childComponent==='function') {\n\t\t\t// set up high order component link\n\n\t\t\tlet childProps = getNodeProps(rendered);\n\t\t\tinst = initialChildComponent;\n\n\t\t\tif (inst && inst.constructor===childComponent && childProps.key==inst.__key) {\n\t\t\t\tsetComponentProps(inst, childProps, SYNC_RENDER, context, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttoUnmount = inst;\n\n\t\t\t\tcomponent._component = inst = createComponent(childComponent, childProps, context);\n\t\t\t\tinst.nextBase = inst.nextBase || nextBase;\n\t\t\t\tinst._parentComponent = component;\n\t\t\t\tsetComponentProps(inst, childProps, NO_RENDER, context, false);\n\t\t\t\trenderComponent(inst, SYNC_RENDER, mountAll, true);\n\t\t\t}\n\n\t\t\tbase = inst.base;\n\t\t}\n\t\telse {\n\t\t\tcbase = initialBase;\n\n\t\t\t// destroy high order component link\n\t\t\ttoUnmount = initialChildComponent;\n\t\t\tif (toUnmount) {\n\t\t\t\tcbase = component._component = null;\n\t\t\t}\n\n\t\t\tif (initialBase || opts===SYNC_RENDER) {\n\t\t\t\tif (cbase) cbase._component = null;\n\t\t\t\tbase = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);\n\t\t\t}\n\t\t}\n\n\t\tif (initialBase && base!==initialBase && inst!==initialChildComponent) {\n\t\t\tlet baseParent = initialBase.parentNode;\n\t\t\tif (baseParent && base!==baseParent) {\n\t\t\t\tbaseParent.replaceChild(base, initialBase);\n\n\t\t\t\tif (!toUnmount) {\n\t\t\t\t\tinitialBase._component = null;\n\t\t\t\t\trecollectNodeTree(initialBase, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toUnmount) {\n\t\t\tunmountComponent(toUnmount);\n\t\t}\n\n\t\tcomponent.base = base;\n\t\tif (base && !isChild) {\n\t\t\tlet componentRef = component,\n\t\t\t\tt = component;\n\t\t\twhile ((t=t._parentComponent)) {\n\t\t\t\t(componentRef = t).base = base;\n\t\t\t}\n\t\t\tbase._component = componentRef;\n\t\t\tbase._componentConstructor = componentRef.constructor;\n\t\t}\n\t}\n\n\tif (!isUpdate || mountAll) {\n\t\tmounts.unshift(component);\n\t}\n\telse if (!skip) {\n\t\t// Ensure that pending componentDidMount() hooks of child components\n\t\t// are called before the componentDidUpdate() hook in the parent.\n\t\tflushMounts();\n\n\t\tif (component.componentDidUpdate) {\n\t\t\tcomponent.componentDidUpdate(previousProps, previousState, previousContext);\n\t\t}\n\t\tif (options.afterUpdate) options.afterUpdate(component);\n\t}\n\n\tif (component._renderCallbacks!=null) {\n\t\twhile (component._renderCallbacks.length) component._renderCallbacks.pop().call(component);\n\t}\n\n\tif (!diffLevel && !isChild) flushMounts();\n}\n\n\n\n/** Apply the Component referenced by a VNode to the DOM.\n *\t@param {Element} dom\tThe DOM node to mutate\n *\t@param {VNode} vnode\tA Component-referencing VNode\n *\t@returns {Element} dom\tThe created/mutated element\n *\t@private\n */\nexport function buildComponentFromVNode(dom, vnode, context, mountAll) {\n\tlet c = dom && dom._component,\n\t\toriginalComponent = c,\n\t\toldDom = dom,\n\t\tisDirectOwner = c && dom._componentConstructor===vnode.nodeName,\n\t\tisOwner = isDirectOwner,\n\t\tprops = getNodeProps(vnode);\n\twhile (c && !isOwner && (c=c._parentComponent)) {\n\t\tisOwner = c.constructor===vnode.nodeName;\n\t}\n\n\tif (c && isOwner && (!mountAll || c._component)) {\n\t\tsetComponentProps(c, props, ASYNC_RENDER, context, mountAll);\n\t\tdom = c.base;\n\t}\n\telse {\n\t\tif (originalComponent && !isDirectOwner) {\n\t\t\tunmountComponent(originalComponent);\n\t\t\tdom = oldDom = null;\n\t\t}\n\n\t\tc = createComponent(vnode.nodeName, props, context);\n\t\tif (dom && !c.nextBase) {\n\t\t\tc.nextBase = dom;\n\t\t\t// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:\n\t\t\toldDom = null;\n\t\t}\n\t\tsetComponentProps(c, props, SYNC_RENDER, context, mountAll);\n\t\tdom = c.base;\n\n\t\tif (oldDom && dom!==oldDom) {\n\t\t\toldDom._component = null;\n\t\t\trecollectNodeTree(oldDom, false);\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n\n\n/** Remove a component from the DOM and recycle it.\n *\t@param {Component} component\tThe Component instance to unmount\n *\t@private\n */\nexport function unmountComponent(component) {\n\tif (options.beforeUnmount) options.beforeUnmount(component);\n\n\tlet base = component.base;\n\n\tcomponent._disable = true;\n\n\tif (component.componentWillUnmount) component.componentWillUnmount();\n\n\tcomponent.base = null;\n\n\t// recursively tear down & recollect high-order component children:\n\tlet inner = component._component;\n\tif (inner) {\n\t\tunmountComponent(inner);\n\t}\n\telse if (base) {\n\t\tif (base[ATTR_KEY] && base[ATTR_KEY].ref) base[ATTR_KEY].ref(null);\n\n\t\tcomponent.nextBase = base;\n\n\t\tremoveNode(base);\n\t\tcollectComponent(component);\n\n\t\tremoveChildren(base);\n\t}\n\n\tif (component.__ref) component.__ref(null);\n}\n","import { FORCE_RENDER } from './constants';\nimport { extend } from './util';\nimport { renderComponent } from './vdom/component';\nimport { enqueueRender } from './render-queue';\n\n/** Base Component class.\n *\tProvides `setState()` and `forceUpdate()`, which trigger rendering.\n *\t@public\n *\n *\t@example\n *\tclass MyFoo extends Component {\n *\t\trender(props, state) {\n *\t\t\treturn <div />;\n *\t\t}\n *\t}\n */\nexport function Component(props, context) {\n\tthis._dirty = true;\n\n\t/** @public\n\t *\t@type {object}\n\t */\n\tthis.context = context;\n\n\t/** @public\n\t *\t@type {object}\n\t */\n\tthis.props = props;\n\n\t/** @public\n\t *\t@type {object}\n\t */\n\tthis.state = this.state || {};\n}\n\n\nextend(Component.prototype, {\n\n\t/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.\n\t *\t@param {object} nextProps\n\t *\t@param {object} nextState\n\t *\t@param {object} nextContext\n\t *\t@returns {Boolean} should the component re-render\n\t *\t@name shouldComponentUpdate\n\t *\t@function\n\t */\n\n\n\t/** Update component state by copying properties from `state` to `this.state`.\n\t *\t@param {object} state\t\tA hash of state properties to update with new values\n\t *\t@param {function} callback\tA function to be called once component state is updated\n\t */\n\tsetState(state, callback) {\n\t\tlet s = this.state;\n\t\tif (!this.prevState) this.prevState = extend({}, s);\n\t\textend(s, typeof state==='function' ? state(s, this.props) : state);\n\t\tif (callback) (this._renderCallbacks = (this._renderCallbacks || [])).push(callback);\n\t\tenqueueRender(this);\n\t},\n\n\n\t/** Immediately perform a synchronous re-render of the component.\n\t *\t@param {function} callback\t\tA function to be called after component is re-rendered.\n\t *\t@private\n\t */\n\tforceUpdate(callback) {\n\t\tif (callback) (this._renderCallbacks = (this._renderCallbacks || [])).push(callback);\n\t\trenderComponent(this, FORCE_RENDER);\n\t},\n\n\n\t/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n\t *\tVirtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n\t *\t@param {object} props\t\tProps (eg: JSX attributes) received from parent element/component\n\t *\t@param {object} state\t\tThe component's current state\n\t *\t@param {object} context\t\tContext object (if a parent component has provided context)\n\t *\t@returns VNode\n\t */\n\trender() {}\n\n});\n","/* @flow */\nimport type {PlainStyle, Style} from './Types';\n\n// currently used to initiate the velocity style object to 0\nexport default function mapToZero(obj: Style | PlainStyle): PlainStyle {\n  let ret = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      ret[key] = 0;\n    }\n  }\n  return ret;\n}\n","/* @flow */\n// turn {x: {val: 1, stiffness: 1, damping: 2}, y: 2} generated by\n// `{x: spring(1, {stiffness: 1, damping: 2}), y: 2}` into {x: 1, y: 2}\n\nimport type {Style, PlainStyle} from './Types';\n\nexport default function stripStyle(style: Style): PlainStyle {\n  let ret = {};\n  for (const key in style) {\n    if (!Object.prototype.hasOwnProperty.call(style, key)) {\n      continue;\n    }\n    ret[key] = typeof style[key] === 'number' ? style[key] : style[key].val;\n  }\n  return ret;\n}\n","/* @flow */\n\n// stepper is used a lot. Saves allocation to return the same array wrapper.\n// This is fine and danger-free against mutations because the callsite\n// immediately destructures it and gets the numbers inside without passing the\n// array reference around.\nlet reusedTuple: [number, number] = [0, 0];\nexport default function stepper(\n  secondPerFrame: number,\n  x: number,\n  v: number,\n  destX: number,\n  k: number,\n  b: number,\n  precision: number): [number, number] {\n  // Spring stiffness, in kg / s^2\n\n  // for animations, destX is really spring length (spring at rest). initial\n  // position is considered as the stretched/compressed position of a spring\n  const Fspring = -k * (x - destX);\n\n  // Damping, in kg / s\n  const Fdamper = -b * v;\n\n  // usually we put mass here, but for animation purposes, specifying mass is a\n  // bit redundant. you could simply adjust k and b accordingly\n  // let a = (Fspring + Fdamper) / mass;\n  const a = Fspring + Fdamper;\n\n  const newV = v + a * secondPerFrame;\n  const newX = x + newV * secondPerFrame;\n\n  if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {\n    reusedTuple[0] = destX;\n    reusedTuple[1] = 0;\n    return reusedTuple;\n  }\n\n  reusedTuple[0] = newX;\n  reusedTuple[1] = newV;\n  return reusedTuple;\n}\n","/* @flow */\nimport type {PlainStyle, Style, Velocity} from './Types';\n\n// usage assumption: currentStyle values have already been rendered but it says\n// nothing of whether currentStyle is stale (see unreadPropStyle)\nexport default function shouldStopAnimation(\n  currentStyle: PlainStyle,\n  style: Style,\n  currentVelocity: Velocity,\n): boolean {\n  for (let key in style) {\n    if (!Object.prototype.hasOwnProperty.call(style, key)) {\n      continue;\n    }\n\n    if (currentVelocity[key] !== 0) {\n      return false;\n    }\n\n    const styleValue = typeof style[key] === 'number'\n      ? style[key]\n      : style[key].val;\n    // stepper will have already taken care of rounding precision errors, so\n    // won't have such thing as 0.9999 !=== 1\n    if (currentStyle[key] !== styleValue) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","\"use strict\";\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;","/* @flow */\nimport mapToZero from './mapToZero';\nimport stripStyle from './stripStyle';\nimport stepper from './stepper';\nimport defaultNow from 'performance-now';\nimport defaultRaf from 'raf';\nimport shouldStopAnimation from './shouldStopAnimation';\nimport { Component } from 'preact';\nimport PropTypes from 'prop-types';\n\nimport type {ReactElement, PlainStyle, Style, Velocity, StaggeredProps} from './Types';\n\nconst msPerFrame = 1000 / 60;\n\ntype StaggeredMotionState = {\n  currentStyles: Array<PlainStyle>,\n  currentVelocities: Array<Velocity>,\n  lastIdealStyles: Array<PlainStyle>,\n  lastIdealVelocities: Array<Velocity>,\n};\n\nfunction shouldStopAnimationAll(\n  currentStyles: Array<PlainStyle>,\n  styles: Array<Style>,\n  currentVelocities: Array<Velocity>,\n): boolean {\n  for (let i = 0; i < currentStyles.length; i++) {\n    if (!shouldStopAnimation(currentStyles[i], styles[i], currentVelocities[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport default class StaggeredMotion extends Component {\n  static propTypes = {\n    // TOOD: warn against putting a config in here\n    defaultStyles: PropTypes.arrayOf(PropTypes.objectOf(PropTypes.number)),\n    styles: PropTypes.func.isRequired,\n    // Preact TODO: check if it's an array containing a single function\n  };\n\n  state: StaggeredMotionState;\n  props: StaggeredProps;\n\n  constructor(props: StaggeredProps) {\n    super(props);\n    this.state = this.defaultState();\n  }\n\n  defaultState(): StaggeredMotionState {\n    const {defaultStyles, styles} = this.props;\n    const currentStyles: Array<PlainStyle> = defaultStyles || styles().map(stripStyle);\n    const currentVelocities = currentStyles.map(currentStyle => mapToZero(currentStyle));\n    return {\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles: currentStyles,\n      lastIdealVelocities: currentVelocities,\n    };\n  }\n\n  animationID: ?number = null;\n  prevTime = 0;\n  accumulatedTime = 0;\n  // it's possible that currentStyle's value is stale: if props is immediately\n  // changed from 0 to 400 to spring(0) again, the async currentStyle is still\n  // at 0 (didn't have time to tick and interpolate even once). If we naively\n  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).\n  // In reality currentStyle should be 400\n  unreadPropStyles: ?Array<Style> = null;\n\n  // after checking for unreadPropStyles != null, we manually go set the\n  // non-interpolating values (those that are a number, without a spring\n  // config)\n  clearUnreadPropStyle = (unreadPropStyles: Array<Style>): void => {\n    let {currentStyles, currentVelocities, lastIdealStyles, lastIdealVelocities} = this.state;\n\n    let someDirty = false;\n    for (let i = 0; i < unreadPropStyles.length; i++) {\n      const unreadPropStyle = unreadPropStyles[i];\n      let dirty = false;\n\n      for (let key in unreadPropStyle) {\n        if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {\n          continue;\n        }\n\n        const styleValue = unreadPropStyle[key];\n        if (typeof styleValue === 'number') {\n          if (!dirty) {\n            dirty = true;\n            someDirty = true;\n            currentStyles[i] = {...currentStyles[i]};\n            currentVelocities[i] = {...currentVelocities[i]};\n            lastIdealStyles[i] = {...lastIdealStyles[i]};\n            lastIdealVelocities[i] = {...lastIdealVelocities[i]};\n          }\n          currentStyles[i][key] = styleValue;\n          currentVelocities[i][key] = 0;\n          lastIdealStyles[i][key] = styleValue;\n          lastIdealVelocities[i][key] = 0;\n        }\n      }\n    }\n\n    if (someDirty) {\n      this.setState({currentStyles, currentVelocities, lastIdealStyles, lastIdealVelocities});\n    }\n  }\n\n  startAnimationIfNecessary = (): void => {\n    // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and\n    // call cb? No, otherwise accidental parent rerender causes cb trigger\n    this.animationID = defaultRaf((timestamp) => {\n      const destStyles: Array<Style> = this.props.styles(this.state.lastIdealStyles);\n\n      // check if we need to animate in the first place\n      if (shouldStopAnimationAll(\n          this.state.currentStyles,\n          destStyles,\n          this.state.currentVelocities,\n        )) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.accumulatedTime = 0;\n        return;\n      }\n\n      const currentTime = timestamp || defaultNow();\n      const timeDelta = currentTime - this.prevTime;\n      this.prevTime = currentTime;\n      this.accumulatedTime = this.accumulatedTime + timeDelta;\n      // more than 10 frames? prolly switched browser tab. Restart\n      if (this.accumulatedTime > msPerFrame * 10) {\n        this.accumulatedTime = 0;\n      }\n\n      if (this.accumulatedTime === 0) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.startAnimationIfNecessary();\n        return;\n      }\n\n      let currentFrameCompletion =\n        (this.accumulatedTime - Math.floor(this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;\n      const framesToCatchUp = Math.floor(this.accumulatedTime / msPerFrame);\n\n      let newLastIdealStyles = [];\n      let newLastIdealVelocities = [];\n      let newCurrentStyles = [];\n      let newCurrentVelocities = [];\n\n      for (let i = 0; i < destStyles.length; i++) {\n        const destStyle = destStyles[i];\n        let newCurrentStyle: PlainStyle = {};\n        let newCurrentVelocity: Velocity = {};\n        let newLastIdealStyle: PlainStyle = {};\n        let newLastIdealVelocity: Velocity = {};\n\n        for (let key in destStyle) {\n          if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {\n            continue;\n          }\n\n          const styleValue = destStyle[key];\n          if (typeof styleValue === 'number') {\n            newCurrentStyle[key] = styleValue;\n            newCurrentVelocity[key] = 0;\n            newLastIdealStyle[key] = styleValue;\n            newLastIdealVelocity[key] = 0;\n          } else {\n            let newLastIdealStyleValue = this.state.lastIdealStyles[i][key];\n            let newLastIdealVelocityValue = this.state.lastIdealVelocities[i][key];\n            for (let j = 0; j < framesToCatchUp; j++) {\n              [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(\n                msPerFrame / 1000,\n                newLastIdealStyleValue,\n                newLastIdealVelocityValue,\n                styleValue.val,\n                styleValue.stiffness,\n                styleValue.damping,\n                styleValue.precision,\n              );\n            }\n            const [nextIdealX, nextIdealV] = stepper(\n              msPerFrame / 1000,\n              newLastIdealStyleValue,\n              newLastIdealVelocityValue,\n              styleValue.val,\n              styleValue.stiffness,\n              styleValue.damping,\n              styleValue.precision,\n            );\n\n            newCurrentStyle[key] =\n              newLastIdealStyleValue +\n              (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n            newCurrentVelocity[key] =\n              newLastIdealVelocityValue +\n              (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n            newLastIdealStyle[key] = newLastIdealStyleValue;\n            newLastIdealVelocity[key] = newLastIdealVelocityValue;\n          }\n        }\n\n        newCurrentStyles[i] = newCurrentStyle;\n        newCurrentVelocities[i] = newCurrentVelocity;\n        newLastIdealStyles[i] = newLastIdealStyle;\n        newLastIdealVelocities[i] = newLastIdealVelocity;\n      }\n\n      this.animationID = null;\n      // the amount we're looped over above\n      this.accumulatedTime -= framesToCatchUp * msPerFrame;\n\n      this.setState({\n        currentStyles: newCurrentStyles,\n        currentVelocities: newCurrentVelocities,\n        lastIdealStyles: newLastIdealStyles,\n        lastIdealVelocities: newLastIdealVelocities,\n      });\n\n      this.unreadPropStyles = null;\n\n      this.startAnimationIfNecessary();\n    });\n  }\n\n  componentDidMount() {\n    this.prevTime = defaultNow();\n    this.startAnimationIfNecessary();\n  }\n\n  componentWillReceiveProps(props: StaggeredProps) {\n    if (this.unreadPropStyles != null) {\n      // previous props haven't had the chance to be set yet; set them here\n      this.clearUnreadPropStyle(this.unreadPropStyles);\n    }\n\n    this.unreadPropStyles = props.styles(this.state.lastIdealStyles);\n    if (this.animationID == null) {\n      this.prevTime = defaultNow();\n      this.startAnimationIfNecessary();\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.animationID != null) {\n      defaultRaf.cancel(this.animationID);\n      this.animationID = null;\n    }\n  }\n\n  render(): ReactElement {\n    return this.props.children[0](this.state.currentStyles);\n  }\n}\n","/* @flow */\nimport type {TransitionStyle} from './Types';\n\n// core keys merging algorithm. If previous render's keys are [a, b], and the\n// next render's [c, b, d], what's the final merged keys and ordering?\n\n// - c and a must both be before b\n// - b before d\n// - ordering between a and c ambiguous\n\n// this reduces to merging two partially ordered lists (e.g. lists where not\n// every item has a definite ordering, like comparing a and c above). For the\n// ambiguous ordering we deterministically choose to place the next render's\n// item after the previous'; so c after a\n\n// this is called a topological sorting. Except the existing algorithms don't\n// work well with js bc of the amount of allocation, and isn't optimized for our\n// current use-case bc the runtime is linear in terms of edges (see wiki for\n// meaning), which is huge when two lists have many common elements\nexport default function mergeDiff(\n  prev: Array<TransitionStyle>,\n  next: Array<TransitionStyle>,\n  onRemove: (prevIndex: number, prevStyleCell: TransitionStyle) => ?TransitionStyle\n): Array<TransitionStyle> {\n  // bookkeeping for easier access of a key's index below. This is 2 allocations +\n  // potentially triggering chrome hash map mode for objs (so it might be faster\n  // to loop through and find a key's index each time), but I no longer care\n  let prevKeyIndex: {[key: string]: number} = {};\n  for (let i = 0; i < prev.length; i++) {\n    prevKeyIndex[prev[i].key] = i;\n  }\n  let nextKeyIndex: {[key: string]: number} = {};\n  for (let i = 0; i < next.length; i++) {\n    nextKeyIndex[next[i].key] = i;\n  }\n\n  // first, an overly elaborate way of merging prev and next, eliminating\n  // duplicates (in terms of keys). If there's dupe, keep the item in next).\n  // This way of writing it saves allocations\n  let ret = [];\n  for (let i = 0; i < next.length; i++) {\n    ret[i] = next[i];\n  }\n  for (let i = 0; i < prev.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(nextKeyIndex, prev[i].key)) {\n      // this is called my TM's `mergeAndSync`, which calls willLeave. We don't\n      // merge in keys that the user desires to kill\n      const fill = onRemove(i, prev[i]);\n      if (fill != null) {\n        ret.push(fill);\n      }\n    }\n  }\n\n  // now all the items all present. Core sorting logic to have the right order\n  return ret.sort((a, b) => {\n    const nextOrderA = nextKeyIndex[a.key];\n    const nextOrderB = nextKeyIndex[b.key];\n    const prevOrderA = prevKeyIndex[a.key];\n    const prevOrderB = prevKeyIndex[b.key];\n\n    if (nextOrderA != null && nextOrderB != null) {\n      // both keys in next\n      return nextKeyIndex[a.key] - nextKeyIndex[b.key];\n    } else if (prevOrderA != null && prevOrderB != null) {\n      // both keys in prev\n      return prevKeyIndex[a.key] - prevKeyIndex[b.key];\n    } else if (nextOrderA != null) {\n      // key a in next, key b in prev\n\n      // how to determine the order between a and b? We find a \"pivot\" (term\n      // abuse), a key present in both prev and next, that is sandwiched between\n      // a and b. In the context of our above example, if we're comparing a and\n      // d, b's (the only) pivot\n      for (let i = 0; i < next.length; i++) {\n        const pivot = next[i].key;\n        if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {\n          continue;\n        }\n\n        if (nextOrderA < nextKeyIndex[pivot] && prevOrderB > prevKeyIndex[pivot]) {\n          return -1;\n        } else if (nextOrderA > nextKeyIndex[pivot] && prevOrderB < prevKeyIndex[pivot]) {\n          return 1;\n        }\n      }\n      // pluggable. default to: next bigger than prev\n      return 1;\n    }\n    // prevOrderA, nextOrderB\n    for (let i = 0; i < next.length; i++) {\n      const pivot = next[i].key;\n      if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {\n        continue;\n      }\n      if (nextOrderB < nextKeyIndex[pivot] && prevOrderA > prevKeyIndex[pivot]) {\n        return 1;\n      } else if (nextOrderB > nextKeyIndex[pivot] && prevOrderA < prevKeyIndex[pivot]) {\n        return -1;\n      }\n    }\n    // pluggable. default to: next bigger than prev\n    return -1;\n  });\n}\n","/* @flow */\nimport mapToZero from './mapToZero';\nimport stripStyle from './stripStyle';\nimport stepper from './stepper';\nimport mergeDiff from './mergeDiff';\nimport defaultNow from 'performance-now';\nimport defaultRaf from 'raf';\nimport shouldStopAnimation from './shouldStopAnimation';\nimport { Component } from 'preact';\nimport PropTypes from 'prop-types';\n\nimport type {\n  ReactElement,\n  PlainStyle,\n  Velocity,\n  TransitionStyle,\n  TransitionPlainStyle,\n  WillEnter,\n  WillLeave,\n  DidLeave,\n  TransitionProps,\n} from './Types';\n\nconst msPerFrame = 1000 / 60;\n\n// the children function & (potential) styles function asks as param an\n// Array<TransitionPlainStyle>, where each TransitionPlainStyle is of the format\n// {key: string, data?: any, style: PlainStyle}. However, the way we keep\n// internal states doesn't contain such a data structure (check the state and\n// TransitionMotionState). So when children function and others ask for such\n// data we need to generate them on the fly by combining mergedPropsStyles and\n// currentStyles/lastIdealStyles\nfunction rehydrateStyles(\n  mergedPropsStyles: Array<TransitionStyle>,\n  unreadPropStyles: ?Array<TransitionStyle>,\n  plainStyles: Array<PlainStyle>,\n): Array<TransitionPlainStyle> {\n  // Copy the value to a `const` so that Flow understands that the const won't\n  // change and will be non-nullable in the callback below.\n  const cUnreadPropStyles = unreadPropStyles;\n  if (cUnreadPropStyles == null) {\n    return mergedPropsStyles.map((mergedPropsStyle, i) => ({\n      key: mergedPropsStyle.key,\n      data: mergedPropsStyle.data,\n      style: plainStyles[i],\n    }));\n  }\n  return mergedPropsStyles.map((mergedPropsStyle, i) => {\n    for (let j = 0; j < cUnreadPropStyles.length; j++) {\n      if (cUnreadPropStyles[j].key === mergedPropsStyle.key) {\n        return {\n          key: cUnreadPropStyles[j].key,\n          data: cUnreadPropStyles[j].data,\n          style: plainStyles[i],\n        };\n      }\n    }\n    return {key: mergedPropsStyle.key, data: mergedPropsStyle.data, style: plainStyles[i]};\n  });\n}\n\nfunction shouldStopAnimationAll(\n  currentStyles: Array<PlainStyle>,\n  destStyles: Array<TransitionStyle>,\n  currentVelocities: Array<Velocity>,\n  mergedPropsStyles: Array<TransitionStyle>,\n): boolean {\n  if (mergedPropsStyles.length !== destStyles.length) {\n    return false;\n  }\n\n  for (let i = 0; i < mergedPropsStyles.length; i++) {\n    if (mergedPropsStyles[i].key !== destStyles[i].key) {\n      return false;\n    }\n  }\n\n  // we have the invariant that mergedPropsStyles and\n  // currentStyles/currentVelocities/last* are synced in terms of cells, see\n  // mergeAndSync comment for more info\n  for (let i = 0; i < mergedPropsStyles.length; i++) {\n    if (!shouldStopAnimation(\n        currentStyles[i],\n        destStyles[i].style,\n        currentVelocities[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// core key merging logic\n\n// things to do: say previously merged style is {a, b}, dest style (prop) is {b,\n// c}, previous current (interpolating) style is {a, b}\n// **invariant**: current[i] corresponds to merged[i] in terms of key\n\n// steps:\n// turn merged style into {a?, b, c}\n//    add c, value of c is destStyles.c\n//    maybe remove a, aka call willLeave(a), then merged is either {b, c} or {a, b, c}\n// turn current (interpolating) style from {a, b} into {a?, b, c}\n//    maybe remove a\n//    certainly add c, value of c is willEnter(c)\n// loop over merged and construct new current\n// dest doesn't change, that's owner's\nfunction mergeAndSync(\n  willEnter: WillEnter,\n  willLeave: WillLeave,\n  didLeave: DidLeave,\n  oldMergedPropsStyles: Array<TransitionStyle>,\n  destStyles: Array<TransitionStyle>,\n  oldCurrentStyles: Array<PlainStyle>,\n  oldCurrentVelocities: Array<Velocity>,\n  oldLastIdealStyles: Array<PlainStyle>,\n  oldLastIdealVelocities: Array<Velocity>,\n): [Array<TransitionStyle>, Array<PlainStyle>, Array<Velocity>, Array<PlainStyle>, Array<Velocity>] {\n  const newMergedPropsStyles = mergeDiff(\n    oldMergedPropsStyles,\n    destStyles,\n    (oldIndex, oldMergedPropsStyle) => {\n      const leavingStyle = willLeave(oldMergedPropsStyle);\n      if (leavingStyle == null) {\n        didLeave({ key: oldMergedPropsStyle.key, data: oldMergedPropsStyle.data });\n        return null;\n      }\n      if (shouldStopAnimation(\n          oldCurrentStyles[oldIndex],\n          leavingStyle,\n          oldCurrentVelocities[oldIndex])) {\n        didLeave({ key: oldMergedPropsStyle.key, data: oldMergedPropsStyle.data });\n        return null;\n      }\n      return {key: oldMergedPropsStyle.key, data: oldMergedPropsStyle.data, style: leavingStyle};\n    },\n  );\n\n  let newCurrentStyles = [];\n  let newCurrentVelocities = [];\n  let newLastIdealStyles = [];\n  let newLastIdealVelocities = [];\n  for (let i = 0; i < newMergedPropsStyles.length; i++) {\n    const newMergedPropsStyleCell = newMergedPropsStyles[i];\n    let foundOldIndex = null;\n    for (let j = 0; j < oldMergedPropsStyles.length; j++) {\n      if (oldMergedPropsStyles[j].key === newMergedPropsStyleCell.key) {\n        foundOldIndex = j;\n        break;\n      }\n    }\n    // TODO: key search code\n    if (foundOldIndex == null) {\n      const plainStyle = willEnter(newMergedPropsStyleCell);\n      newCurrentStyles[i] = plainStyle;\n      newLastIdealStyles[i] = plainStyle;\n\n      const velocity = mapToZero(newMergedPropsStyleCell.style);\n      newCurrentVelocities[i] = velocity;\n      newLastIdealVelocities[i] = velocity;\n    } else {\n      newCurrentStyles[i] = oldCurrentStyles[foundOldIndex];\n      newLastIdealStyles[i] = oldLastIdealStyles[foundOldIndex];\n      newCurrentVelocities[i] = oldCurrentVelocities[foundOldIndex];\n      newLastIdealVelocities[i] = oldLastIdealVelocities[foundOldIndex];\n    }\n  }\n\n  return [newMergedPropsStyles, newCurrentStyles, newCurrentVelocities, newLastIdealStyles, newLastIdealVelocities];\n}\n\ntype TransitionMotionDefaultProps = {\n  willEnter: WillEnter,\n  willLeave: WillLeave,\n  didLeave: DidLeave\n}\n\ntype TransitionMotionState = {\n  // list of styles, each containing interpolating values. Part of what's passed\n  // to children function. Notice that this is\n  // Array<ActualInterpolatingStyleObject>, without the wrapper that is {key: ...,\n  // data: ... style: ActualInterpolatingStyleObject}. Only mergedPropsStyles\n  // contains the key & data info (so that we only have a single source of truth\n  // for these, and to save space). Check the comment for `rehydrateStyles` to\n  // see how we regenerate the entirety of what's passed to children function\n  currentStyles: Array<PlainStyle>,\n  currentVelocities: Array<Velocity>,\n  lastIdealStyles: Array<PlainStyle>,\n  lastIdealVelocities: Array<Velocity>,\n  // the array that keeps track of currently rendered stuff! Including stuff\n  // that you've unmounted but that's still animating. This is where it lives\n  mergedPropsStyles: Array<TransitionStyle>,\n};\n\nexport default class TransitionMotion extends Component {\n  static propTypes = {\n    defaultStyles: PropTypes.arrayOf(PropTypes.shape({\n      key: PropTypes.string.isRequired,\n      data: PropTypes.any,\n      style: PropTypes.objectOf(PropTypes.number).isRequired,\n    })),\n    styles: PropTypes.oneOfType([\n      PropTypes.func,\n      PropTypes.arrayOf(PropTypes.shape({\n        key: PropTypes.string.isRequired,\n        data: PropTypes.any,\n        style: PropTypes.objectOf(PropTypes.oneOfType([\n          PropTypes.number,\n          PropTypes.object,\n        ])).isRequired,\n      }),\n      )]).isRequired,\n    // Preact TODO: check if it's an array containing a single function\n    // children: PropTypes.func.isRequired,\n    willEnter: PropTypes.func,\n    willLeave: PropTypes.func,\n    didLeave: PropTypes.func,\n  };\n\n  static defaultProps: TransitionMotionDefaultProps = {\n    willEnter: styleThatEntered => stripStyle(styleThatEntered.style),\n    // recall: returning null makes the current unmounting TransitionStyle\n    // disappear immediately\n    willLeave: () => null,\n    didLeave: () => {},\n  };\n\n  state: TransitionMotionState;\n  props: TransitionProps;\n\n  unmounting: boolean = false;\n  animationID: ?number = null;\n  prevTime = 0;\n  accumulatedTime = 0;\n  // it's possible that currentStyle's value is stale: if props is immediately\n  // changed from 0 to 400 to spring(0) again, the async currentStyle is still\n  // at 0 (didn't have time to tick and interpolate even once). If we naively\n  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).\n  // In reality currentStyle should be 400\n  unreadPropStyles: ?Array<TransitionStyle> = null;\n\n  constructor(props: TransitionProps) {\n    super(props);\n    this.state = this.defaultState();\n  }\n\n  defaultState(): TransitionMotionState {\n    const {defaultStyles, styles, willEnter, willLeave, didLeave} = this.props;\n    const destStyles: Array<TransitionStyle> = typeof styles === 'function' ? styles(defaultStyles) : styles;\n\n    // this is special. for the first time around, we don't have a comparison\n    // between last (no last) and current merged props. we'll compute last so:\n    // say default is {a, b} and styles (dest style) is {b, c}, we'll\n    // fabricate last as {a, b}\n    let oldMergedPropsStyles: Array<TransitionStyle>;\n    if (defaultStyles == null) {\n      oldMergedPropsStyles = destStyles;\n    } else {\n      oldMergedPropsStyles = (defaultStyles: any).map(defaultStyleCell => {\n        // TODO: key search code\n        for (let i = 0; i < destStyles.length; i++) {\n          if (destStyles[i].key === defaultStyleCell.key) {\n            return destStyles[i];\n          }\n        }\n        return defaultStyleCell;\n      });\n    }\n    const oldCurrentStyles = defaultStyles == null\n      ? destStyles.map(s => stripStyle(s.style))\n      : (defaultStyles: any).map(s => stripStyle(s.style));\n    const oldCurrentVelocities = defaultStyles == null\n      ? destStyles.map(s => mapToZero(s.style))\n      : defaultStyles.map(s => mapToZero(s.style));\n    const [mergedPropsStyles, currentStyles, currentVelocities, lastIdealStyles, lastIdealVelocities] = mergeAndSync(\n      // Because this is an old-style createReactClass component, Flow doesn't\n      // understand that the willEnter and willLeave props have default values\n      // and will always be present.\n      (willEnter: any),\n      (willLeave: any),\n      (didLeave: any),\n      oldMergedPropsStyles,\n      destStyles,\n      oldCurrentStyles,\n      oldCurrentVelocities,\n      oldCurrentStyles, // oldLastIdealStyles really\n      oldCurrentVelocities, // oldLastIdealVelocities really\n    );\n\n    return {\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles,\n      lastIdealVelocities,\n      mergedPropsStyles,\n    };\n  }\n\n  // after checking for unreadPropStyles != null, we manually go set the\n  // non-interpolating values (those that are a number, without a spring\n  // config)\n  clearUnreadPropStyle = (unreadPropStyles: Array<TransitionStyle>): void => {\n    let [mergedPropsStyles, currentStyles, currentVelocities, lastIdealStyles, lastIdealVelocities] = mergeAndSync(\n      (this.props.willEnter: any),\n      (this.props.willLeave: any),\n      (this.props.didLeave: any),\n      this.state.mergedPropsStyles,\n      unreadPropStyles,\n      this.state.currentStyles,\n      this.state.currentVelocities,\n      this.state.lastIdealStyles,\n      this.state.lastIdealVelocities,\n    );\n\n    for (let i = 0; i < unreadPropStyles.length; i++) {\n      const unreadPropStyle = unreadPropStyles[i].style;\n      let dirty = false;\n\n      for (let key in unreadPropStyle) {\n        if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {\n          continue;\n        }\n\n        const styleValue = unreadPropStyle[key];\n        if (typeof styleValue === 'number') {\n          if (!dirty) {\n            dirty = true;\n            currentStyles[i] = {...currentStyles[i]};\n            currentVelocities[i] = {...currentVelocities[i]};\n            lastIdealStyles[i] = {...lastIdealStyles[i]};\n            lastIdealVelocities[i] = {...lastIdealVelocities[i]};\n            mergedPropsStyles[i] = {\n              key: mergedPropsStyles[i].key,\n              data: mergedPropsStyles[i].data,\n              style: {...mergedPropsStyles[i].style},\n            };\n          }\n          currentStyles[i][key] = styleValue;\n          currentVelocities[i][key] = 0;\n          lastIdealStyles[i][key] = styleValue;\n          lastIdealVelocities[i][key] = 0;\n          mergedPropsStyles[i].style[key] = styleValue;\n        }\n      }\n    }\n\n    // unlike the other 2 components, we can't detect staleness and optionally\n    // opt out of setState here. each style object's data might contain new\n    // stuff we're not/cannot compare\n    this.setState({\n      currentStyles,\n      currentVelocities,\n      mergedPropsStyles,\n      lastIdealStyles,\n      lastIdealVelocities,\n    });\n  }\n\n  startAnimationIfNecessary = (): void => {\n    if (this.unmounting) {\n      return;\n    }\n\n    // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and\n    // call cb? No, otherwise accidental parent rerender causes cb trigger\n    this.animationID = defaultRaf((timestamp) => {\n      // https://github.com/chenglou/react-motion/pull/420\n      // > if execution passes the conditional if (this.unmounting), then\n      // executes async defaultRaf and after that component unmounts and after\n      // that the callback of defaultRaf is called, then setState will be called\n      // on unmounted component.\n      if (this.unmounting) {\n        return;\n      }\n\n      const propStyles = this.props.styles;\n      let destStyles: Array<TransitionStyle> = typeof propStyles === 'function'\n        ? propStyles(rehydrateStyles(\n          this.state.mergedPropsStyles,\n          this.unreadPropStyles,\n          this.state.lastIdealStyles,\n        ))\n        : propStyles;\n\n      // check if we need to animate in the first place\n      if (shouldStopAnimationAll(\n          this.state.currentStyles,\n          destStyles,\n          this.state.currentVelocities,\n          this.state.mergedPropsStyles,\n        )) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.accumulatedTime = 0;\n        return;\n      }\n\n      const currentTime = timestamp || defaultNow();\n      const timeDelta = currentTime - this.prevTime;\n      this.prevTime = currentTime;\n      this.accumulatedTime = this.accumulatedTime + timeDelta;\n      // more than 10 frames? prolly switched browser tab. Restart\n      if (this.accumulatedTime > msPerFrame * 10) {\n        this.accumulatedTime = 0;\n      }\n\n      if (this.accumulatedTime === 0) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.startAnimationIfNecessary();\n        return;\n      }\n\n      let currentFrameCompletion =\n        (this.accumulatedTime - Math.floor(this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;\n      const framesToCatchUp = Math.floor(this.accumulatedTime / msPerFrame);\n\n      let [newMergedPropsStyles, newCurrentStyles, newCurrentVelocities, newLastIdealStyles, newLastIdealVelocities] = mergeAndSync(\n        (this.props.willEnter: any),\n        (this.props.willLeave: any),\n        (this.props.didLeave: any),\n        this.state.mergedPropsStyles,\n        destStyles,\n        this.state.currentStyles,\n        this.state.currentVelocities,\n        this.state.lastIdealStyles,\n        this.state.lastIdealVelocities,\n      );\n      for (let i = 0; i < newMergedPropsStyles.length; i++) {\n        const newMergedPropsStyle = newMergedPropsStyles[i].style;\n        let newCurrentStyle: PlainStyle = {};\n        let newCurrentVelocity: Velocity = {};\n        let newLastIdealStyle: PlainStyle = {};\n        let newLastIdealVelocity: Velocity = {};\n\n        for (let key in newMergedPropsStyle) {\n          if (!Object.prototype.hasOwnProperty.call(newMergedPropsStyle, key)) {\n            continue;\n          }\n\n          const styleValue = newMergedPropsStyle[key];\n          if (typeof styleValue === 'number') {\n            newCurrentStyle[key] = styleValue;\n            newCurrentVelocity[key] = 0;\n            newLastIdealStyle[key] = styleValue;\n            newLastIdealVelocity[key] = 0;\n          } else {\n            let newLastIdealStyleValue = newLastIdealStyles[i][key];\n            let newLastIdealVelocityValue = newLastIdealVelocities[i][key];\n            for (let j = 0; j < framesToCatchUp; j++) {\n              [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(\n                msPerFrame / 1000,\n                newLastIdealStyleValue,\n                newLastIdealVelocityValue,\n                styleValue.val,\n                styleValue.stiffness,\n                styleValue.damping,\n                styleValue.precision,\n              );\n            }\n            const [nextIdealX, nextIdealV] = stepper(\n              msPerFrame / 1000,\n              newLastIdealStyleValue,\n              newLastIdealVelocityValue,\n              styleValue.val,\n              styleValue.stiffness,\n              styleValue.damping,\n              styleValue.precision,\n            );\n\n            newCurrentStyle[key] =\n              newLastIdealStyleValue +\n              (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n            newCurrentVelocity[key] =\n              newLastIdealVelocityValue +\n              (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n            newLastIdealStyle[key] = newLastIdealStyleValue;\n            newLastIdealVelocity[key] = newLastIdealVelocityValue;\n          }\n        }\n\n        newLastIdealStyles[i] = newLastIdealStyle;\n        newLastIdealVelocities[i] = newLastIdealVelocity;\n        newCurrentStyles[i] = newCurrentStyle;\n        newCurrentVelocities[i] = newCurrentVelocity;\n      }\n\n      this.animationID = null;\n      // the amount we're looped over above\n      this.accumulatedTime -= framesToCatchUp * msPerFrame;\n\n      this.setState({\n        currentStyles: newCurrentStyles,\n        currentVelocities: newCurrentVelocities,\n        lastIdealStyles: newLastIdealStyles,\n        lastIdealVelocities: newLastIdealVelocities,\n        mergedPropsStyles: newMergedPropsStyles,\n      });\n\n      this.unreadPropStyles = null;\n\n      this.startAnimationIfNecessary();\n    });\n  }\n\n  componentDidMount() {\n    this.prevTime = defaultNow();\n    this.startAnimationIfNecessary();\n  }\n\n  componentWillReceiveProps(props: TransitionProps) {\n    if (this.unreadPropStyles) {\n      // previous props haven't had the chance to be set yet; set them here\n      this.clearUnreadPropStyle(this.unreadPropStyles);\n    }\n\n    const styles = props.styles;\n    if (typeof styles === 'function') {\n      this.unreadPropStyles = styles(\n        rehydrateStyles(\n          this.state.mergedPropsStyles,\n          this.unreadPropStyles,\n          this.state.lastIdealStyles,\n        )\n      );\n    } else {\n      this.unreadPropStyles = styles;\n    }\n\n    if (this.animationID == null) {\n      this.prevTime = defaultNow();\n      this.startAnimationIfNecessary();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n    if (this.animationID != null) {\n      defaultRaf.cancel(this.animationID);\n      this.animationID = null;\n    }\n  }\n\n  render(): ReactElement {\n    const hydratedStyles = rehydrateStyles(\n      this.state.mergedPropsStyles,\n      this.unreadPropStyles,\n      this.state.currentStyles,\n    );\n    return this.props.children[0](hydratedStyles);\n  }\n}\n\n","/* @flow */\nimport presets from './presets';\nimport type {OpaqueConfig, SpringHelperConfig} from './Types';\n\nconst defaultConfig = {\n  ...presets.noWobble,\n  precision: 0.01,\n};\n\nexport default function spring(val: number, config?: SpringHelperConfig): OpaqueConfig {\n  return {...defaultConfig, ...config, val};\n}\n","/** Global options\n *\t@public\n *\t@namespace options {Object}\n */\nexport default {\n\n\t/** If `true`, `prop` changes trigger synchronous component updates.\n\t *\t@name syncComponentUpdates\n\t *\t@type Boolean\n\t *\t@default true\n\t */\n\t//syncComponentUpdates: true,\n\n\t/** Processes all created VNodes.\n\t *\t@param {VNode} vnode\tA newly-created VNode to normalize/process\n\t */\n\t//vnode(vnode) { }\n\n\t/** Hook invoked after a component is mounted. */\n\t// afterMount(component) { }\n\n\t/** Hook invoked after the DOM is updated with a component's latest render. */\n\t// afterUpdate(component) { }\n\n\t/** Hook invoked immediately before a component is unmounted. */\n\t// beforeUnmount(component) { }\n};\n","// render modes\n\nexport const NO_RENDER = 0;\nexport const SYNC_RENDER = 1;\nexport const FORCE_RENDER = 2;\nexport const ASYNC_RENDER = 3;\n\n\nexport const ATTR_KEY = '__preactattr_';\n\n// DOM properties that should NOT have \"px\" added when numeric\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\n","var now = require('performance-now')\n  , root = typeof window === 'undefined' ? global : window\n  , vendors = ['moz', 'webkit']\n  , suffix = 'AnimationFrame'\n  , raf = root['request' + suffix]\n  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]\n\nfor(var i = 0; !raf && i < vendors.length; i++) {\n  raf = root[vendors[i] + 'Request' + suffix]\n  caf = root[vendors[i] + 'Cancel' + suffix]\n      || root[vendors[i] + 'CancelRequest' + suffix]\n}\n\n// Some versions of FF have rAF but not cAF\nif(!raf || !caf) {\n  var last = 0\n    , id = 0\n    , queue = []\n    , frameDuration = 1000 / 60\n\n  raf = function(callback) {\n    if(queue.length === 0) {\n      var _now = now()\n        , next = Math.max(0, frameDuration - (_now - last))\n      last = next + _now\n      setTimeout(function() {\n        var cp = queue.slice(0)\n        // Clear queue here to prevent\n        // callbacks from appending listeners\n        // to the current frame's queue\n        queue.length = 0\n        for(var i = 0; i < cp.length; i++) {\n          if(!cp[i].cancelled) {\n            try{\n              cp[i].callback(last)\n            } catch(e) {\n              setTimeout(function() { throw e }, 0)\n            }\n          }\n        }\n      }, Math.round(next))\n    }\n    queue.push({\n      handle: ++id,\n      callback: callback,\n      cancelled: false\n    })\n    return id\n  }\n\n  caf = function(handle) {\n    for(var i = 0; i < queue.length; i++) {\n      if(queue[i].handle === handle) {\n        queue[i].cancelled = true\n      }\n    }\n  }\n}\n\nmodule.exports = function(fn) {\n  // Wrap in a new function to prevent\n  // `cancel` potentially being assigned\n  // to the native rAF function\n  return raf.call(root, fn)\n}\nmodule.exports.cancel = function() {\n  caf.apply(root, arguments)\n}\nmodule.exports.polyfill = function() {\n  root.requestAnimationFrame = raf\n  root.cancelAnimationFrame = caf\n}\n","// Generated by CoffeeScript 1.7.1\n(function() {\n  var getNanoSeconds, hrtime, loadTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - loadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    loadTime = getNanoSeconds();\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n","/* @flow */\nimport mapToZero from './mapToZero';\nimport stripStyle from './stripStyle';\nimport stepper from './stepper';\nimport defaultNow from 'performance-now';\nimport defaultRaf from 'raf';\nimport shouldStopAnimation from './shouldStopAnimation';\nimport { Component } from 'preact';\nimport PropTypes from 'prop-types';\n\nimport type {ReactElement, PlainStyle, Style, Velocity, MotionProps} from './Types';\n\nconst msPerFrame = 1000 / 60;\n\ntype MotionState = {\n  currentStyle: PlainStyle,\n  currentVelocity: Velocity,\n  lastIdealStyle: PlainStyle,\n  lastIdealVelocity: Velocity,\n};\n\nexport default class Motion extends Component {\n  static propTypes = {\n    // TOOD: warn against putting a config in here\n    defaultStyle: PropTypes.objectOf(PropTypes.number),\n    style: PropTypes.objectOf(PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.object,\n    ])).isRequired,\n    // Preact TODO: check if it's an array containing a single function\n    // children: PropTypes.func.isRequired,\n    onRest: PropTypes.func,\n  };\n\n  state: MotionState;\n  props: MotionProps;\n\n  constructor(props: MotionProps) {\n    super(props);\n    this.state = this.defaultState();\n  }\n\n  wasAnimating: boolean = false;\n  animationID: ?number = null;\n  prevTime: number = 0;\n  accumulatedTime: number = 0;\n\n  defaultState(): MotionState {\n    const {defaultStyle, style} = this.props;\n    const currentStyle = defaultStyle || stripStyle(style);\n    const currentVelocity = mapToZero(currentStyle);\n    return {\n      currentStyle,\n      currentVelocity,\n      lastIdealStyle: currentStyle,\n      lastIdealVelocity: currentVelocity,\n    };\n  }\n\n  // it's possible that currentStyle's value is stale: if props is immediately\n  // changed from 0 to 400 to spring(0) again, the async currentStyle is still\n  // at 0 (didn't have time to tick and interpolate even once). If we naively\n  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).\n  // In reality currentStyle should be 400\n  unreadPropStyle: ?Style = null;\n  // after checking for unreadPropStyle != null, we manually go set the\n  // non-interpolating values (those that are a number, without a spring\n  // config)\n  clearUnreadPropStyle = (destStyle: Style): void => {\n    let dirty = false;\n    let {currentStyle, currentVelocity, lastIdealStyle, lastIdealVelocity} = this.state;\n\n    for (let key in destStyle) {\n      if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {\n        continue;\n      }\n\n      const styleValue = destStyle[key];\n      if (typeof styleValue === 'number') {\n        if (!dirty) {\n          dirty = true;\n          currentStyle = {...currentStyle};\n          currentVelocity = {...currentVelocity};\n          lastIdealStyle = {...lastIdealStyle};\n          lastIdealVelocity = {...lastIdealVelocity};\n        }\n\n        currentStyle[key] = styleValue;\n        currentVelocity[key] = 0;\n        lastIdealStyle[key] = styleValue;\n        lastIdealVelocity[key] = 0;\n      }\n    }\n\n    if (dirty) {\n      this.setState({currentStyle, currentVelocity, lastIdealStyle, lastIdealVelocity});\n    }\n  };\n\n  startAnimationIfNecessary = (): void => {\n    // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and\n    // call cb? No, otherwise accidental parent rerender causes cb trigger\n    this.animationID = defaultRaf((timestamp) => {\n      // check if we need to animate in the first place\n      const propsStyle: Style = this.props.style;\n      if (shouldStopAnimation(\n        this.state.currentStyle,\n        propsStyle,\n        this.state.currentVelocity,\n      )) {\n        if (this.wasAnimating && this.props.onRest) {\n          this.props.onRest();\n        }\n\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.wasAnimating = false;\n        this.accumulatedTime = 0;\n        return;\n      }\n\n      this.wasAnimating = true;\n\n      const currentTime = timestamp || defaultNow();\n      const timeDelta = currentTime - this.prevTime;\n      this.prevTime = currentTime;\n      this.accumulatedTime = this.accumulatedTime + timeDelta;\n      // more than 10 frames? prolly switched browser tab. Restart\n      if (this.accumulatedTime > msPerFrame * 10) {\n        this.accumulatedTime = 0;\n      }\n\n      if (this.accumulatedTime === 0) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.startAnimationIfNecessary();\n        return;\n      }\n\n      let currentFrameCompletion =\n        (this.accumulatedTime - Math.floor(this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;\n      const framesToCatchUp = Math.floor(this.accumulatedTime / msPerFrame);\n\n      let newLastIdealStyle: PlainStyle = {};\n      let newLastIdealVelocity: Velocity = {};\n      let newCurrentStyle: PlainStyle = {};\n      let newCurrentVelocity: Velocity = {};\n\n      for (let key in propsStyle) {\n        if (!Object.prototype.hasOwnProperty.call(propsStyle, key)) {\n          continue;\n        }\n\n        const styleValue = propsStyle[key];\n        if (typeof styleValue === 'number') {\n          newCurrentStyle[key] = styleValue;\n          newCurrentVelocity[key] = 0;\n          newLastIdealStyle[key] = styleValue;\n          newLastIdealVelocity[key] = 0;\n        } else {\n          let newLastIdealStyleValue = this.state.lastIdealStyle[key];\n          let newLastIdealVelocityValue = this.state.lastIdealVelocity[key];\n          for (let i = 0; i < framesToCatchUp; i++) {\n            [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(\n              msPerFrame / 1000,\n              newLastIdealStyleValue,\n              newLastIdealVelocityValue,\n              styleValue.val,\n              styleValue.stiffness,\n              styleValue.damping,\n              styleValue.precision,\n            );\n          }\n          const [nextIdealX, nextIdealV] = stepper(\n            msPerFrame / 1000,\n            newLastIdealStyleValue,\n            newLastIdealVelocityValue,\n            styleValue.val,\n            styleValue.stiffness,\n            styleValue.damping,\n            styleValue.precision,\n          );\n\n          newCurrentStyle[key] =\n            newLastIdealStyleValue +\n            (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n          newCurrentVelocity[key] =\n            newLastIdealVelocityValue +\n            (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n          newLastIdealStyle[key] = newLastIdealStyleValue;\n          newLastIdealVelocity[key] = newLastIdealVelocityValue;\n        }\n      }\n\n      this.animationID = null;\n      // the amount we're looped over above\n      this.accumulatedTime -= framesToCatchUp * msPerFrame;\n\n      this.setState({\n        currentStyle: newCurrentStyle,\n        currentVelocity: newCurrentVelocity,\n        lastIdealStyle: newLastIdealStyle,\n        lastIdealVelocity: newLastIdealVelocity,\n      });\n\n      this.unreadPropStyle = null;\n\n      this.startAnimationIfNecessary();\n    });\n  };\n\n  componentDidMount() {\n    this.prevTime = defaultNow();\n    this.startAnimationIfNecessary();\n  }\n\n  componentWillReceiveProps(props: MotionProps) {\n    if (this.unreadPropStyle != null) {\n      // previous props haven't had the chance to be set yet; set them here\n      this.clearUnreadPropStyle(this.unreadPropStyle);\n    }\n\n    this.unreadPropStyle = props.style;\n    if (this.animationID == null) {\n      this.prevTime = defaultNow();\n      this.startAnimationIfNecessary();\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.animationID != null) {\n      defaultRaf.cancel(this.animationID);\n      this.animationID = null;\n    }\n  }\n\n  render(): ReactElement {\n    return this.props.children[0](this.state.currentStyle);\n  }\n}\n","/* @flow */\nexport default {\n  noWobble: {stiffness: 170, damping: 26}, // the default, if nothing provided\n  gentle: {stiffness: 120, damping: 14},\n  wobbly: {stiffness: 180, damping: 12},\n  stiff: {stiffness: 210, damping: 20},\n};\n","import { Component, h } from 'preact';\nimport {Motion, spring} from '../../src';\n\nexport default class Demo extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {open: false};\n  };\n\n  handleMouseDown = () => {\n    this.setState({open: !this.state.open});\n  };\n\n  handleTouchStart = (e) => {\n    e.preventDefault();\n    this.handleMouseDown();\n  };\n\n  render() {\n    return (\n      <div>\n        <button\n          onMouseDown={this.handleMouseDown}\n          onTouchStart={this.handleTouchStart}>\n          Toggle\n        </button>\n\n        <Motion style={{x: spring(this.state.open ? 400 : 0)}}>\n          {({x}) =>\n            // children is a callback which should accept the current value of\n            // `style`\n            <div className=\"demo0\">\n              <div className=\"demo0-block\" style={{\n                WebkitTransform: `translate3d(${x}px, 0, 0)`,\n                transform: `translate3d(${x}px, 0, 0)`,\n              }} />\n            </div>\n          }\n        </Motion>\n      </div>\n    );\n  };\n}\n","import { diff } from './vdom/diff';\n\n/** Render JSX into a `parent` Element.\n *\t@param {VNode} vnode\t\tA (JSX) VNode to render\n *\t@param {Element} parent\t\tDOM element to render into\n *\t@param {Element} [merge]\tAttempt to re-use an existing DOM tree rooted at `merge`\n *\t@public\n *\n *\t@example\n *\t// render a div into <body>:\n *\trender(<div id=\"hello\">hello!</div>, document.body);\n *\n *\t@example\n *\t// render a \"Thing\" component into #foo:\n *\tconst Thing = ({ name }) => <span>{ name }</span>;\n *\trender(<Thing name=\"one\" />, document.querySelector('#foo'));\n */\nexport function render(vnode, parent, merge) {\n\treturn diff(merge, vnode, {}, false, parent, false);\n}\n","import { render, h } from 'preact';\nimport Demo from './Demo';\n\nrender(<Demo />, document.querySelector('#content'));\n"],"names":["VNode","h","nodeName","attributes","children","EMPTY_CHILDREN","lastSimple","child","simple","i","arguments","length","push","stack","pop","undefined","String","p","key","options","vnode","extend","obj","props","enqueueRender","component","_dirty","items","debounceRendering","setTimeout","rerender","list","renderComponent","isSameNodeType","node","hydrating","splitText","_componentConstructor","isNamedNode","normalizedNodeName","toLowerCase","getNodeProps","defaultProps","createNode","isSvg","document","createElementNS","createElement","removeNode","parentNode","removeChild","setAccessor","name","old","value","style","cssText","IS_NON_DIMENSIONAL","test","innerHTML","__html","useCapture","replace","substring","addEventListener","eventProxy","removeEventListener","_listeners","removeAttribute","ns","removeAttributeNS","setAttributeNS","setAttribute","className","setProperty","e","this","type","event","flushMounts","c","mounts","afterMount","componentDidMount","diff","dom","context","mountAll","parent","componentRoot","diffLevel","ownerSVGElement","ATTR_KEY","ret","idiff","appendChild","out","prevSvgMode","isSvgMode","_component","nodeValue","createTextNode","replaceChild","buildComponentFromVNode","firstChild","fc","vchildren","nextSibling","dangerouslySetInnerHTML","innerDiffNode","isHydrating","originalChildren","childNodes","keyed","keyedLen","min","len","childrenLen","vlen","j","vchild","__key","trim","insertBefore","recollectNodeTree","unmountOnly","ref","removeChildren","lastChild","next","previousSibling","diffAttributes","attrs","collectComponent","constructor","components","createComponent","Ctor","inst","prototype","render","call","Component","doRender","nextBase","splice","state","setComponentProps","opts","_disable","__ref","base","componentWillMount","componentWillReceiveProps","prevContext","prevProps","NO_RENDER","SYNC_RENDER","syncComponentUpdates","isChild","previousProps","previousState","prevState","previousContext","isUpdate","initialBase","initialChildComponent","skip","rendered","cbase","FORCE_RENDER","shouldComponentUpdate","componentWillUpdate","getChildContext","childComponent","toUnmount","childProps","_parentComponent","baseParent","componentRef","t","unshift","componentDidUpdate","afterUpdate","_renderCallbacks","originalComponent","oldDom","isDirectOwner","isOwner","ASYNC_RENDER","unmountComponent","beforeUnmount","componentWillUnmount","inner","mapToZero","Object","hasOwnProperty","stripStyle","val","stepper","secondPerFrame","x","v","destX","k","b","precision","Fspring","Fdamper","a","newV","newX","Math","abs","reusedTuple","shouldStopAnimation","currentStyle","currentVelocity","styleValue","makeEmptyFunction","arg","shouldStopAnimationAll","currentStyles","styles","currentVelocities","mergeDiff","prev","onRemove","prevKeyIndex","nextKeyIndex","fill","sort","nextOrderA","nextOrderB","prevOrderA","prevOrderB","pivot","rehydrateStyles","mergedPropsStyles","unreadPropStyles","plainStyles","cUnreadPropStyles","map","mergedPropsStyle","data","destStyles","mergeAndSync","willEnter","willLeave","didLeave","oldMergedPropsStyles","oldCurrentStyles","oldCurrentVelocities","oldLastIdealStyles","oldLastIdealVelocities","newMergedPropsStyles","oldIndex","oldMergedPropsStyle","leavingStyle","newCurrentStyles","newCurrentVelocities","newLastIdealStyles","newLastIdealVelocities","newMergedPropsStyleCell","foundOldIndex","plainStyle","velocity","spring","config","defaultConfig","callback","s","getNanoSeconds","hrtime","loadTime","performance","now","process","hr","Date","getTime","window","global","vendors","suffix","raf","root","caf","last","id","queue","_now","max","cp","slice","cancelled","round","handle","module","fn","apply","requestAnimationFrame","cancelAnimationFrame","emptyFunction","thatReturns","thatReturnsFalse","thatReturnsTrue","thatReturnsNull","thatReturnsThis","thatReturnsArgument","msPerFrame","Motion","_Component","wasAnimating","animationID","prevTime","accumulatedTime","unreadPropStyle","clearUnreadPropStyle","destStyle","dirty","_this","lastIdealStyle","lastIdealVelocity","setState","startAnimationIfNecessary","defaultRaf","timestamp","propsStyle","onRest","currentTime","defaultNow","timeDelta","currentFrameCompletion","floor","framesToCatchUp","newLastIdealStyle","newLastIdealVelocity","newCurrentStyle","newCurrentVelocity","newLastIdealStyleValue","newLastIdealVelocityValue","stiffness","damping","nextIdealX","nextIdealV","defaultState","defaultStyle","cancel","lastIdealStyles","lastIdealVelocities","someDirty","defaultStyles","unmounting","propStyles","newMergedPropsStyle","defaultStyleCell","hydratedStyles","styleThatEntered","presets","noWobble","Demo","handleMouseDown","open","handleTouchStart","preventDefault","merge","querySelector"],"mappings":"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"}